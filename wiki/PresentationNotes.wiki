#summary Notes regarding the algorithms, data structures, and sundry in jaigo for presentation.

= Presentation Slides =
[http://docs.google.com/PresentationEditor?id=dgk2kqwp_171cqpccwft Jaigo: Javascript-based Artificially Intelligent Go Opponent]

= Go =
  * Board (square grid, common sizes: 19, 13, 9)
  * Stones (signify control by a player of a grid position)
  * Liberties for c (unoccupied grid positions orthogonally adjacent to a stone of color c)
  * Chains (contiguous extents of stones of the same color)
  * Capture (the state of a chain with no liberties; captured chains are removed from the board)
  * Suicide (capturing your own chain)
  * Ko rule (no cycles shorter than 3 turns permitted)
  * Turn (pass or place a stone)

Objective: control more area or territory than opponent

zero-sum, perfect information, partisan (some moves are available to one player but not the other), deterministic strategy game

= Computer Go =
Search tree bf typically 150--250.
Endgames are PSPACE-hard.

Known techniques:
  * minimax (α-ß pruning, transposition tables, iterative deepening)
  * monte carlo
  * genetic algorithms
  * neural networks

= Interaction/UI = 

Output in [http://www.lysator.liu.se/~gunnar/gtp/ GTP], so any GTP-compatible UI works.

= Scoring =
The board is scored using [http://senseis.xmp.net/?BensonsAlgorithm Benson's Algorithm].

= Board representation =
We have 3^361 board states, perhaps 10^768 games. Representing the board turns out to be the most difficult part of writing a go engine.

= Engine choice =
What is the engine with the smallest expression in javascript and the highest kyu ranking?

== SimpleGo v1 ==
== SimpleGO v3 ==
== Crawler ==
== TinyGo ==

= Size =
~76KB, unoptimized.

= Speed =